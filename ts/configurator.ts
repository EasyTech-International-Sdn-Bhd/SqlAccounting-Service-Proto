// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "configurator.proto" (package "proto", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message proto.CreateRequest
 */
export interface CreateRequest {
    /**
     * @generated from protobuf field: string username = 1;
     */
    username: string;
    /**
     * @generated from protobuf field: string password = 2;
     */
    password: string;
    /**
     * @generated from protobuf field: string url = 3;
     */
    url: string;
    /**
     * @generated from protobuf field: string appName = 4;
     */
    appName: string;
}
/**
 * @generated from protobuf message proto.IsDcfParsableRequest
 */
export interface IsDcfParsableRequest {
    /**
     * @generated from protobuf field: string dcfPath = 1;
     */
    dcfPath: string;
}
/**
 * @generated from protobuf message proto.Database
 */
export interface Database {
    /**
     * @generated from protobuf field: string database = 1;
     */
    database: string;
    /**
     * @generated from protobuf field: string companyName = 2;
     */
    companyName: string;
    /**
     * @generated from protobuf field: string remark = 3;
     */
    remark: string;
    /**
     * @generated from protobuf field: string version = 4;
     */
    version: string;
    /**
     * @generated from protobuf field: string dbUsername = 5;
     */
    dbUsername: string;
    /**
     * @generated from protobuf field: string dbPassword = 6;
     */
    dbPassword: string;
}
/**
 * @generated from protobuf message proto.IsDcfParsableResponse
 */
export interface IsDcfParsableResponse {
    /**
     * @generated from protobuf field: repeated proto.Database database = 1;
     */
    database: Database[];
}
/**
 * @generated from protobuf message proto.TempPathRequest
 */
export interface TempPathRequest {
    /**
     * @generated from protobuf field: string tempPath = 1;
     */
    tempPath: string;
}
/**
 * @generated from protobuf message proto.PatchUrlRequest
 */
export interface PatchUrlRequest {
    /**
     * @generated from protobuf field: string patchUrl = 1;
     */
    patchUrl: string;
}
/**
 * @generated from protobuf message proto.HookUrlRequest
 */
export interface HookUrlRequest {
    /**
     * @generated from protobuf field: string hookUrl = 1;
     */
    hookUrl: string;
}
/**
 * @generated from protobuf message proto.ReachableRequest
 */
export interface ReachableRequest {
    /**
     * @generated from protobuf field: string url = 1;
     */
    url: string;
}
/**
 * @generated from protobuf message proto.LoginConfiguratorRequest
 */
export interface LoginConfiguratorRequest {
    /**
     * @generated from protobuf field: string username = 1;
     */
    username: string;
    /**
     * @generated from protobuf field: string password = 2;
     */
    password: string;
}
/**
 * @generated from protobuf message proto.PluginResult
 */
export interface PluginResult {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string error = 2;
     */
    error: string;
}
/**
 * @generated from protobuf message proto.PluginResponse
 */
export interface PluginResponse {
    /**
     * @generated from protobuf field: repeated proto.PluginResult res = 1;
     */
    res: PluginResult[];
}
/**
 * @generated from protobuf message proto.Empty
 */
export interface Empty {
}
// @generated message type with reflection information, may provide speed optimized methods
class CreateRequest$Type extends MessageType<CreateRequest> {
    constructor() {
        super("proto.CreateRequest", [
            { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "appName", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreateRequest>): CreateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.username = "";
        message.password = "";
        message.url = "";
        message.appName = "";
        if (value !== undefined)
            reflectionMergePartial<CreateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateRequest): CreateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string username */ 1:
                    message.username = reader.string();
                    break;
                case /* string password */ 2:
                    message.password = reader.string();
                    break;
                case /* string url */ 3:
                    message.url = reader.string();
                    break;
                case /* string appName */ 4:
                    message.appName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string username = 1; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        /* string password = 2; */
        if (message.password !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.password);
        /* string url = 3; */
        if (message.url !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.url);
        /* string appName = 4; */
        if (message.appName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.appName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.CreateRequest
 */
export const CreateRequest = new CreateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IsDcfParsableRequest$Type extends MessageType<IsDcfParsableRequest> {
    constructor() {
        super("proto.IsDcfParsableRequest", [
            { no: 1, name: "dcfPath", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<IsDcfParsableRequest>): IsDcfParsableRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dcfPath = "";
        if (value !== undefined)
            reflectionMergePartial<IsDcfParsableRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IsDcfParsableRequest): IsDcfParsableRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string dcfPath */ 1:
                    message.dcfPath = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IsDcfParsableRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string dcfPath = 1; */
        if (message.dcfPath !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.dcfPath);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.IsDcfParsableRequest
 */
export const IsDcfParsableRequest = new IsDcfParsableRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Database$Type extends MessageType<Database> {
    constructor() {
        super("proto.Database", [
            { no: 1, name: "database", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "companyName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "remark", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "dbUsername", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "dbPassword", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Database>): Database {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.database = "";
        message.companyName = "";
        message.remark = "";
        message.version = "";
        message.dbUsername = "";
        message.dbPassword = "";
        if (value !== undefined)
            reflectionMergePartial<Database>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Database): Database {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string database */ 1:
                    message.database = reader.string();
                    break;
                case /* string companyName */ 2:
                    message.companyName = reader.string();
                    break;
                case /* string remark */ 3:
                    message.remark = reader.string();
                    break;
                case /* string version */ 4:
                    message.version = reader.string();
                    break;
                case /* string dbUsername */ 5:
                    message.dbUsername = reader.string();
                    break;
                case /* string dbPassword */ 6:
                    message.dbPassword = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Database, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string database = 1; */
        if (message.database !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.database);
        /* string companyName = 2; */
        if (message.companyName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.companyName);
        /* string remark = 3; */
        if (message.remark !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.remark);
        /* string version = 4; */
        if (message.version !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.version);
        /* string dbUsername = 5; */
        if (message.dbUsername !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.dbUsername);
        /* string dbPassword = 6; */
        if (message.dbPassword !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.dbPassword);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.Database
 */
export const Database = new Database$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IsDcfParsableResponse$Type extends MessageType<IsDcfParsableResponse> {
    constructor() {
        super("proto.IsDcfParsableResponse", [
            { no: 1, name: "database", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Database }
        ]);
    }
    create(value?: PartialMessage<IsDcfParsableResponse>): IsDcfParsableResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.database = [];
        if (value !== undefined)
            reflectionMergePartial<IsDcfParsableResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IsDcfParsableResponse): IsDcfParsableResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated proto.Database database */ 1:
                    message.database.push(Database.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IsDcfParsableResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated proto.Database database = 1; */
        for (let i = 0; i < message.database.length; i++)
            Database.internalBinaryWrite(message.database[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.IsDcfParsableResponse
 */
export const IsDcfParsableResponse = new IsDcfParsableResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TempPathRequest$Type extends MessageType<TempPathRequest> {
    constructor() {
        super("proto.TempPathRequest", [
            { no: 1, name: "tempPath", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TempPathRequest>): TempPathRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tempPath = "";
        if (value !== undefined)
            reflectionMergePartial<TempPathRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TempPathRequest): TempPathRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tempPath */ 1:
                    message.tempPath = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TempPathRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tempPath = 1; */
        if (message.tempPath !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tempPath);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.TempPathRequest
 */
export const TempPathRequest = new TempPathRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PatchUrlRequest$Type extends MessageType<PatchUrlRequest> {
    constructor() {
        super("proto.PatchUrlRequest", [
            { no: 1, name: "patchUrl", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PatchUrlRequest>): PatchUrlRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.patchUrl = "";
        if (value !== undefined)
            reflectionMergePartial<PatchUrlRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PatchUrlRequest): PatchUrlRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string patchUrl */ 1:
                    message.patchUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PatchUrlRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string patchUrl = 1; */
        if (message.patchUrl !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.patchUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.PatchUrlRequest
 */
export const PatchUrlRequest = new PatchUrlRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HookUrlRequest$Type extends MessageType<HookUrlRequest> {
    constructor() {
        super("proto.HookUrlRequest", [
            { no: 1, name: "hookUrl", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HookUrlRequest>): HookUrlRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hookUrl = "";
        if (value !== undefined)
            reflectionMergePartial<HookUrlRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HookUrlRequest): HookUrlRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string hookUrl */ 1:
                    message.hookUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HookUrlRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string hookUrl = 1; */
        if (message.hookUrl !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.hookUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.HookUrlRequest
 */
export const HookUrlRequest = new HookUrlRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReachableRequest$Type extends MessageType<ReachableRequest> {
    constructor() {
        super("proto.ReachableRequest", [
            { no: 1, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ReachableRequest>): ReachableRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.url = "";
        if (value !== undefined)
            reflectionMergePartial<ReachableRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReachableRequest): ReachableRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string url */ 1:
                    message.url = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReachableRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string url = 1; */
        if (message.url !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.url);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.ReachableRequest
 */
export const ReachableRequest = new ReachableRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginConfiguratorRequest$Type extends MessageType<LoginConfiguratorRequest> {
    constructor() {
        super("proto.LoginConfiguratorRequest", [
            { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LoginConfiguratorRequest>): LoginConfiguratorRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.username = "";
        message.password = "";
        if (value !== undefined)
            reflectionMergePartial<LoginConfiguratorRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginConfiguratorRequest): LoginConfiguratorRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string username */ 1:
                    message.username = reader.string();
                    break;
                case /* string password */ 2:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginConfiguratorRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string username = 1; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        /* string password = 2; */
        if (message.password !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.LoginConfiguratorRequest
 */
export const LoginConfiguratorRequest = new LoginConfiguratorRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginResult$Type extends MessageType<PluginResult> {
    constructor() {
        super("proto.PluginResult", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PluginResult>): PluginResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.error = "";
        if (value !== undefined)
            reflectionMergePartial<PluginResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginResult): PluginResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string error */ 2:
                    message.error = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string error = 2; */
        if (message.error !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.PluginResult
 */
export const PluginResult = new PluginResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginResponse$Type extends MessageType<PluginResponse> {
    constructor() {
        super("proto.PluginResponse", [
            { no: 1, name: "res", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PluginResult }
        ]);
    }
    create(value?: PartialMessage<PluginResponse>): PluginResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.res = [];
        if (value !== undefined)
            reflectionMergePartial<PluginResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginResponse): PluginResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated proto.PluginResult res */ 1:
                    message.res.push(PluginResult.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated proto.PluginResult res = 1; */
        for (let i = 0; i < message.res.length; i++)
            PluginResult.internalBinaryWrite(message.res[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.PluginResponse
 */
export const PluginResponse = new PluginResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Empty$Type extends MessageType<Empty> {
    constructor() {
        super("proto.Empty", []);
    }
    create(value?: PartialMessage<Empty>): Empty {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Empty>(this, message, value);
        return message;
    }
    internalBinaryRead(_reader: IBinaryReader, _length: number, _options: BinaryReadOptions, target?: Empty): Empty {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Empty, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.Empty
 */
export const Empty = new Empty$Type();
/**
 * @generated ServiceType for protobuf service proto.SetupConfigurator
 */
export const SetupConfigurator = new ServiceType("proto.SetupConfigurator", [
    { name: "Create", options: {}, I: CreateRequest, O: Empty },
    { name: "IsDcfParsable", options: {}, I: IsDcfParsableRequest, O: IsDcfParsableResponse },
    { name: "SetDatabase", options: {}, I: Database, O: Empty },
    { name: "SetTempPath", options: {}, I: TempPathRequest, O: Empty },
    { name: "SetPatchUrl", options: {}, I: PatchUrlRequest, O: Empty },
    { name: "SetHookUrl", options: {}, I: HookUrlRequest, O: Empty },
    { name: "IsReachable", options: {}, I: ReachableRequest, O: Empty },
    { name: "LoginConfigurator", options: {}, I: LoginConfiguratorRequest, O: Empty },
    { name: "InstallPlugins", options: {}, I: Empty, O: PluginResponse },
    { name: "UninstallPlugins", options: {}, I: Empty, O: PluginResponse }
]);
