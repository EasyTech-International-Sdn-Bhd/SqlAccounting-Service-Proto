// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "configurator.proto" (package "proto", syntax proto3)
// tslint:disable
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { SetupConfigurator } from "./configurator";
import type { PluginResponse } from "./configurator";
import type { LoginConfiguratorRequest } from "./configurator";
import type { ReachableRequest } from "./configurator";
import type { HookUrlRequest } from "./configurator";
import type { PatchUrlRequest } from "./configurator";
import type { TempPathRequest } from "./configurator";
import type { Database } from "./configurator";
import type { IsDcfParsableResponse } from "./configurator";
import type { IsDcfParsableRequest } from "./configurator";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { Empty } from "./configurator";
import type { CreateRequest } from "./configurator";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * @generated from protobuf service proto.SetupConfigurator
 */
export interface ISetupConfiguratorClient {
    /**
     * @generated from protobuf rpc: Create(proto.CreateRequest) returns (proto.Empty);
     */
    create(input: CreateRequest, options?: RpcOptions): UnaryCall<CreateRequest, Empty>;
    /**
     * @generated from protobuf rpc: IsDcfParsable(proto.IsDcfParsableRequest) returns (proto.IsDcfParsableResponse);
     */
    isDcfParsable(input: IsDcfParsableRequest, options?: RpcOptions): UnaryCall<IsDcfParsableRequest, IsDcfParsableResponse>;
    /**
     * @generated from protobuf rpc: SetDatabase(proto.Database) returns (proto.Empty);
     */
    setDatabase(input: Database, options?: RpcOptions): UnaryCall<Database, Empty>;
    /**
     * @generated from protobuf rpc: SetTempPath(proto.TempPathRequest) returns (proto.Empty);
     */
    setTempPath(input: TempPathRequest, options?: RpcOptions): UnaryCall<TempPathRequest, Empty>;
    /**
     * @generated from protobuf rpc: SetPatchUrl(proto.PatchUrlRequest) returns (proto.Empty);
     */
    setPatchUrl(input: PatchUrlRequest, options?: RpcOptions): UnaryCall<PatchUrlRequest, Empty>;
    /**
     * @generated from protobuf rpc: SetHookUrl(proto.HookUrlRequest) returns (proto.Empty);
     */
    setHookUrl(input: HookUrlRequest, options?: RpcOptions): UnaryCall<HookUrlRequest, Empty>;
    /**
     * @generated from protobuf rpc: IsReachable(proto.ReachableRequest) returns (proto.Empty);
     */
    isReachable(input: ReachableRequest, options?: RpcOptions): UnaryCall<ReachableRequest, Empty>;
    /**
     * @generated from protobuf rpc: LoginConfigurator(proto.LoginConfiguratorRequest) returns (proto.Empty);
     */
    loginConfigurator(input: LoginConfiguratorRequest, options?: RpcOptions): UnaryCall<LoginConfiguratorRequest, Empty>;
    /**
     * @generated from protobuf rpc: InstallPlugins(proto.Empty) returns (proto.PluginResponse);
     */
    installPlugins(input: Empty, options?: RpcOptions): UnaryCall<Empty, PluginResponse>;
    /**
     * @generated from protobuf rpc: UninstallPlugins(proto.Empty) returns (proto.PluginResponse);
     */
    uninstallPlugins(input: Empty, options?: RpcOptions): UnaryCall<Empty, PluginResponse>;
}
/**
 * @generated from protobuf service proto.SetupConfigurator
 */
export class SetupConfiguratorClient implements ISetupConfiguratorClient, ServiceInfo {
    typeName = SetupConfigurator.typeName;
    methods = SetupConfigurator.methods;
    options = SetupConfigurator.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * @generated from protobuf rpc: Create(proto.CreateRequest) returns (proto.Empty);
     */
    create(input: CreateRequest, options?: RpcOptions): UnaryCall<CreateRequest, Empty> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<CreateRequest, Empty>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: IsDcfParsable(proto.IsDcfParsableRequest) returns (proto.IsDcfParsableResponse);
     */
    isDcfParsable(input: IsDcfParsableRequest, options?: RpcOptions): UnaryCall<IsDcfParsableRequest, IsDcfParsableResponse> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<IsDcfParsableRequest, IsDcfParsableResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: SetDatabase(proto.Database) returns (proto.Empty);
     */
    setDatabase(input: Database, options?: RpcOptions): UnaryCall<Database, Empty> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept<Database, Empty>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: SetTempPath(proto.TempPathRequest) returns (proto.Empty);
     */
    setTempPath(input: TempPathRequest, options?: RpcOptions): UnaryCall<TempPathRequest, Empty> {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept<TempPathRequest, Empty>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: SetPatchUrl(proto.PatchUrlRequest) returns (proto.Empty);
     */
    setPatchUrl(input: PatchUrlRequest, options?: RpcOptions): UnaryCall<PatchUrlRequest, Empty> {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        return stackIntercept<PatchUrlRequest, Empty>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: SetHookUrl(proto.HookUrlRequest) returns (proto.Empty);
     */
    setHookUrl(input: HookUrlRequest, options?: RpcOptions): UnaryCall<HookUrlRequest, Empty> {
        const method = this.methods[5], opt = this._transport.mergeOptions(options);
        return stackIntercept<HookUrlRequest, Empty>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: IsReachable(proto.ReachableRequest) returns (proto.Empty);
     */
    isReachable(input: ReachableRequest, options?: RpcOptions): UnaryCall<ReachableRequest, Empty> {
        const method = this.methods[6], opt = this._transport.mergeOptions(options);
        return stackIntercept<ReachableRequest, Empty>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: LoginConfigurator(proto.LoginConfiguratorRequest) returns (proto.Empty);
     */
    loginConfigurator(input: LoginConfiguratorRequest, options?: RpcOptions): UnaryCall<LoginConfiguratorRequest, Empty> {
        const method = this.methods[7], opt = this._transport.mergeOptions(options);
        return stackIntercept<LoginConfiguratorRequest, Empty>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: InstallPlugins(proto.Empty) returns (proto.PluginResponse);
     */
    installPlugins(input: Empty, options?: RpcOptions): UnaryCall<Empty, PluginResponse> {
        const method = this.methods[8], opt = this._transport.mergeOptions(options);
        return stackIntercept<Empty, PluginResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: UninstallPlugins(proto.Empty) returns (proto.PluginResponse);
     */
    uninstallPlugins(input: Empty, options?: RpcOptions): UnaryCall<Empty, PluginResponse> {
        const method = this.methods[9], opt = this._transport.mergeOptions(options);
        return stackIntercept<Empty, PluginResponse>("unary", this._transport, method, opt, input);
    }
}
